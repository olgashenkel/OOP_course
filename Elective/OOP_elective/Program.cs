
using OOP_elective;
using System;
using System.Drawing;

class Program
{
    static void Main(string[] args)
    {
        Console.SetWindowSize(81, 27);
        Console.SetBufferSize(81, 27); // Console.SetBufferSize - функция задаёт размер окна, что позволяет убрать полосу прокрутки)

        // Отрисовка рамочки:
        //HorizontalLine upLine = new HorizontalLine(0, 80, 0, '+');
        //HorizontalLine downLine = new HorizontalLine(0, 80, 25, '+');
        //VerticalLine leftLine = new VerticalLine(0, 25, 0, '+');
        //VerticalLine rightLine = new VerticalLine(0, 25, 80, '+');
        //upLine.Draw();
        //downLine.Draw();
        //leftLine.Draw();
        //rightLine.Draw();
        Walls walls = new Walls(81, 27);
        walls.Draw();


        // Отрисовка точек
        MyPoint p = new MyPoint(4, 5, '*');
        Snake snake = new Snake(p, 4, Direction.RIGHT);
        snake.Draw();

        //snake.Move();
        //Thread.Sleep(100); // задержка вывода следующего действия на определенное количество времени


        // кормление змейки
        FoodCreator foodCreator = new FoodCreator(81, 27, '$');
        MyPoint food = foodCreator.CreateFood();
        food.Draw();


        while (true)
        {
            if (walls.IsHit(snake) || snake.IsHitTail())
            {
                break;
            }
            if (snake.Eat(food))
            {
                food = foodCreator.CreateFood();
                food.Draw();
            }
            else
            {
                snake.Move();
            }

            Thread.Sleep(100);
            if (Console.KeyAvailable)
            {
                ConsoleKeyInfo key = Console.ReadKey();
                snake.HandleKey(key.Key);
            }
        }

        WriteGameOver();
        Console.ReadLine();


    }

    static void WriteGameOver()
    {
        int xOffset = 25;
        int yOffset = 8;
        Console.ForegroundColor = ConsoleColor.Yellow;
        Console.SetCursorPosition(xOffset, yOffset++);
        WriteText("===================================================", 12, 8);
        WriteText("И Г Р А    О К О Н Ч Е Н А !", 13, 9);
        yOffset++;
        WriteText("Игра создана на основе курса \"Основы ООП\"", 13, 11);
        WriteText("Преподаватель курса GeekBrains: Евгений Картавец", 13, 12);
        WriteText("===================================================", 12, 13);
    }

    static void WriteText(String text, int xOffset, int yOffset)
    {
        Console.SetCursorPosition(xOffset, yOffset);
        Console.WriteLine(text);
    }
}

/* Урок 4. Конструкторы. Инкапсуляция.
 * Инкапсуляция - это свойство системы, позволяющая объединить данные и методы, работающие с ними в классе,
 * и скрыть все детали реализации от пользователя. Таким образом, пользователи класса MyPoint могут и вовсе
 * не знать, как он выглядить изнутри.
 */

/* Урок 5. Оперативная память: вид изнутри.
 * 
 * Стек (stack) — это способ организации данных в памяти компьютера. 
 * Он работает по принципу «последним пришёл, первым вышел» (last in first out, LIFO). 
 * Это значит, что последний элемент, добавленный в стек, будет взят из него первым.
 * 
 *  Куча - это область памяти, где данные могут быть размещены динамически во время выполнения 
 *  программы. В отличие от стека, где данные удаляются автоматически после выхода из функции, 
 *  данные в куче остаются, пока их явно не удалить.
 *  
 */

/* Урок 6. Осваиваем класс «Список»
 * 
 * //List<int> numList = new List<int>();
        //numList.Add(0);
        //numList.Add(1);
        //numList.Add(2);  

        //int x = numList[0];
        //int y = numList[1];
        //int z = numList[2];

        //foreach (int i in numList) // перебор элементов списка
        //{
        //    Console.WriteLine(i);   
        //}

        //numList.RemoveAt(0); // удаление элемента списка

        //List<MyPoint> pList = new List<MyPoint>();
        //pList.Add(p1);
        //pList.Add(p2);
*/

/* Урок 9. Класс «Змейка»
 * Абстракция в программировании – это как упрощение реального объекта до его ключевых характеристик.
 * Представь, что ты рисуешь домик: вместо деталей (кирпичи, окна) ты рисуешь просто квадрат и 
 * треугольник сверху. В коде это помогает сосредоточиться на важном, игнорируя мелочи.
 * 
 * Это решает проблему перегрузки информацией и сложности в коде. 
 * Когда ты работаешь только с тем, что действительно важно, код становится проще и чище. 
 * Это делает разработку быстрее и эффективнее, а также помогает легче понять, как работает программа.
 * Важно знать об абстракции, потому что это упрощает написание программ, 
 * делает их более безопасными и гибкими к изменениям. Это ключ к созданию мощного и 
 * легко поддерживаемого кода.
 * */

/* Урок 13. Класс «Препятствия». Полиморфизм
 * Полиморфизм — это когда мы можем вызывать одни и те же методы у разных классов. 
 * Внутри они могут работать по-разному, но внешне всё будет выглядеть одинаково.
 * 
 * Полиморфизм. Наследование поддерживает концепцию полиморфизма, которая позволяет обращаться к объектам подклассов 
через ссылки на родительские классы. Это облегчает обработку групп объектов с различными типами, 
что упрощает написание общего и универсального кода.
*/

/*
 * Принцип наследования является одним из фундаментальных понятий объектно-ориентированного программирования 
 * и предоставляет несколько преимуществ, которые делают его важным и полезным инструментом при проектировании программных систем:

1/ Повторное использование кода. Наследование позволяет создавать иерархии классов, где общая функциональность реализуется 
в родительском классе, и все подклассы автоматически наследуют этот код. Это способствует повторному использованию кода, 
что уменьшает дублирование и облегчает его поддержку.

2/ Расширяемость. Принцип наследования позволяет создавать новые классы, расширяющие функциональность существующих классов. 
Подклассы могут добавлять новые свойства и методы, а также переопределять поведение унаследованных методов. 
Это делает код более гибким и позволяет легко вносить изменения.

3/ Упрощение кода. Использование наследования позволяет разбивать большие и сложные классы на более мелкие 
и управляемые части. Каждый подкласс специализируется на определенном аспекте функциональности, что упрощает понимание и поддержку кода.

4/ Полиморфизм. Наследование поддерживает концепцию полиморфизма, которая позволяет обращаться к объектам подклассов 
через ссылки на родительские классы. Это облегчает обработку групп объектов с различными типами, что упрощает написание общего и универсального кода.

5/ Абстракция. Наследование позволяет выделить общие характеристики объектов и создать абстрактные классы, 
которые определяют интерфейс для группы связанных классов. Абстрактные классы предоставляют общую сущность 
без необходимости определения всех деталей реализации.

6/ Структурирование кода. Наследование помогает упорядочить классы в логические иерархии, 
что улучшает структуру программы. Каждый класс наследует функциональность от одного или нескольких 
родительских классов, что улучшает организацию кода и делает его более понятным и легко поддерживаемым.
*/