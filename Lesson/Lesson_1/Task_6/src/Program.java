//Все члены класса в языке Java - поля и методы - имеют модификаторы доступа.
// Модификаторы доступа позволяют задать допустимую область видимости для членов класса,
// то есть контекст, в котором можно употреблять данную переменную или метод.
// *******************************
//В Java используются следующие модификаторы доступа:
//
//public: публичный, общедоступный класс или член класса.
//          Поля и методы, объявленные с модификатором public, видны другим классам из текущего пакета
//          и из внешних пакетов.
//
//private: закрытый класс или член класса, противоположность модификатору public.
//          Закрытый класс или член класса доступен только из кода в том же классе.
//
//protected: такой класс или член класса доступен из любого места в текущем классе или пакете
//          или в производных классах, даже если они находятся в других пакетах
//
//Модификатор по умолчанию: Отсутствие модификатора у поля или метода класса предполагает
//          применение к нему модификатора по умолчанию. Такие поля или методы видны всем классам в текущем пакете.


// Если другой класс имеет прямой доступ к этому полю, то есть вероятность,
// что в процессе работы программы ему будет передано некорректное значение, например, отрицательное число.
// Подобное изменение данных не является желательным. Либо же мы хотим, чтобы некоторые данные были доступны
// напрямую, чтобы их можно было вывести на консоль или просто узнать их значение.
// В этой связи рекомендуется как можно больше ограничивать доступ к данным, чтобы защитить их от
// нежелательного доступа извне (как для получения значения, так и для его изменения).
// Использование различных модификаторов гарантирует, что данные не будут искажены или изменены не
// надлежащим образом. Подобное сокрытие данных внутри некоторой области видимости называется !!!инкапсуляцией!!!.

// this и super - это два специальных ключевых слова в Java, которые представляют соответственно
// текущий экземпляр класса и его суперкласса.
// главное отличие между this и super в Java в том, что this представляет текущий экземпляр класса,
// в то время как super - текущий экземпляр родительского класса.

// Чем this и super похожи
//Прежде чем рассматривать отличия ключевых слов this и super, давайте посмотрим на некоторые их сходства:
//И this, и super — это нестатические переменные, соответственно их нельзя использовать в статическом контексте,
// а это означает, что их нельзя использовать в методе main. Это приведет к ошибке во время компиляции "на нестатическую переменную this нельзя ссылаться из статического контекста". То же самое произойдет, если в методе main воспользоваться ключевым словом super.
//
//И this, и super могут использоваться внутри конструкторов для вызова других конструкторов по цепочке,
// нпр., this() и super() вызывают конструктор без аргументов наследующего и родительского классов соответственно.

// Различия в super и this
// Но есть ещё один вариант использования этих ключевых слов - во Внутренних классах,
// где с их помощью очень удобно ссылаться на внешний класс, используя форму записи Outer.this
// для его текущего экземпляра и Outer.super — для его родителя.
// Не забудьте вместо Outer подставить имя внешнего класса.
//
// А теперь давайте кратко перечислим главные отличия между ключевыми словами this и super//
//переменная this ссылается на текущий экземпляр класса, в котором она используется,
//          тогда как super — на текущий экземпляр родительского класса.
//
//Каждый конструктор при отсутствии явных вызовов других конструкторов неявно вызывает с помощью super()
//          конструктор без аргументов родительского класса, при этом у вас всегда остается возможность
//          явно вызвать любой другой конструктор с помощью либо this(), либо super().


public class Program {
    public static void main(String[] args) {
        Magician hero1 = new Magician();
        System.out.println(hero1.getInfo());

        Priest hero2 = new Priest();
        System.out.println(hero2.getInfo());

        Priest hero3 = new Priest();
        System.out.println(hero3.getInfo());

        hero3.GetDamage(hero2.Attack());
        hero3.GetDamage(hero3.Attack());
        System.out.println(hero3.getInfo());
        System.out.println(hero2.getInfo());
        //hero3.GetDamage(hero3.Attack());
    }
}