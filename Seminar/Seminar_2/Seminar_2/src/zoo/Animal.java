package zoo;

/*
Кроме обычных классов в Java есть абстрактные классы.
Абстрактный класс похож на обычный класс. В абстрактном классе также можно определить поля и методы, но в то же время
нельзя создать объект или экземпляр абстрактного класса. Абстрактные классы призваны предоставлять базовый функционал
для классов-наследников. А производные классы уже реализуют этот функционал.

При определении абстрактных классов используется ключевое слово abstract:

public abstract class Human{

    private String name;

    public String getName() { return name; }
}
Но главное отличие состоит в том, что мы не можем использовать конструктор абстрактного класса для создания его объекта.
Например, следующим образом:
    Human h = new Human();
Кроме обычных методов абстрактный класс может содержать абстрактные методы.
Такие методы определяются с помощью ключевого слова abstract и не имеют никакой реализации:
    public abstract void display();
Производный класс обязан переопределить и реализовать все абстрактные методы, которые имеются в базовом абстрактном классе.
Также следует учитывать, что если класс имеет хотя бы один абстрактный метод,
то данный класс должен быть определен как абстрактный.
Зачем нужны абстрактные классы? Допустим, мы делаем программу для обслуживания банковских операций и определяем
в ней три класса: Person, который описывает человека, Employee, который описывает банковского служащего,
и класс Client, который представляет клиента банка.
Очевидно, что классы Employee и Client будут производными от класса Person, так как оба класса имеют некоторые общие поля и методы.
 И так как все объекты будут представлять либо сотрудника, либо клиента банка, то напрямую мы от класса Person
 создавать объекты не будем. Поэтому имеет смысл сделать его абстрактным.
 */

// в public abstract class Animal implements Speakable, Speakable1, Speakable2...
// можно реализовывать сколько угодно интерфейсов (через , )

public abstract class Animal implements Speakable {
    // метод abstract - это метод, у которого нет тела,
    // т.е. его реализация ложится на наследников текущего класса
//    public void speak() {
//        // Обязательное условие - у всех наследников класса должен быть данный метод (speak()),
//        // иначе будет синтаксическая ошибка! (т.е. такой проект даже не соберется)
//
//    }


//    public abstract void speak();
//    // метод, который в interface Speakable и в abstract class Animal - на данный момент это одно и тоже (у них одинаковая сигнатура)
//    // поэтому его можно не писать, и ничего не поменяется, т.е. всё равно наследники должны будут реализовывать метод speak()

    // Абстрактный класс НЕ обязан реализовывать методы implements.
    // если НЕ реализует, то это должны будут делать наследники
    // если реализует, тогда наследники НЕ обязаны переопределять этот метод (можно и так, и так)

    private String name;

    public Animal(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }
}

/*
переопределение методов (Override в Java).

Википедия дает такое пояснение термина «переопределение»:

Переопределение метода (англ. Method overriding) в объектно-ориентированном программировании —
одна из возможностей языка программирования, позволяющая подклассу или дочернему классу обеспечивать
специфическую реализацию метода, уже реализованного в одном из суперклассов или родительских классов.

Оно, в общем-то, правильное. Переопределение позволяет взять какой-то метод родительского класса и написать
в каждом классе-наследнике свою реализацию этого метода. Новая реализация «заменит» родительскую в дочернем классе.

Чтобы задать нужное нам поведение, мы сделали несколько вещей:
1. Создали в каждом классе-наследнике метод с таким же названием, как и у метода в родительском классе.
2. Сообщили компилятору, что мы не просто так назвали метод так же, как в классе-родителе:
хотим переопределить его поведение. Для этого «сообщения» компилятору мы поставили над методом
аннотацию @Override («переопределен»).
3. Проставленная над методом аннотация @Override сообщает компилятору (да и читающим твой код программистам тоже):
«Все ок, это не ошибка и не моя забывчивость. Я помню, что такой метод уже есть, и хочу переопределить его».

Написали нужную нам реализацию для каждого класса-потомка.

!!!!!!!!!!!!!!!!!!!!
У переопределения есть ряд ограничений:

1) У переопределенного метода должны быть те же аргументы, что и у метода родителя.
Если метод voice родительского класса принимает на вход String, переопределенный метод в классе-потомке
тоже должен принимать на вход String, иначе компилятор выдаст ошибку

2) У переопределенного метода должен быть тот же тип возвращаемого значения, что и у метода родителя.
В ином случае мы получим ошибку компиляции

3) Модификатор доступа у переопределенного метода также не может отличаться от «оригинального»

Переопределение методов в Java — один из инструментов для реализации идеи полиморфизма (принципа ООП).
Поэтому главным преимуществом его использования будет та же гибкость.
Мы можем выстроить простую и логичную систему классов, каждый из которых будет обладать специфическим поведением,
но единым интерфейсом — один метод voice() на всех вместо кучи методов voiceDog(), voiceCat() и т.д.
 */